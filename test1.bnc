/*vec3 :: struct {
	x: float = 0;
	y: float = 0;
	z: float = 0;
}

ms :: struct {
	x : float;
	y : float^ [1+22*4+1] ^;
	z : int[..];
	w : GG(int, float);
}*/

/*
y: float^[1 + 22 * 4 + 1]^ = 4;

ss: bool = true;
st: bool = false;
*/

vec3i :: struct {
x: int = 0;
y: int = 0;
z: int = 0;// 4 - 2 * (3 + -555);
}


vec3 :: struct {
x: float = 0.0;
y: float = 0.0;
z: float = 0.0*123.4;// 4 - 2 * (3 + -555);
}


/*
vec3 :: struct {
x: float = 0;
y: float = 0;
z: float = 0;
}

makeVec :: (x : float, y: float, z: float) -> vec3 {
	v : vec3;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}


norm2 :: (v : vec3) -> float {
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
*/

/*
pow :: (b : int, e : int) -> int {
	return -b.xc * e;
}
*/

//p(-b.xc * e);
//cc.v + b.a[p(-b.cc^*34 + er.c^*^t.x^ * h * ^(x.cc + 55))];

//x[c] * (^v[h])[a[b*c[4]]];
//mm.cc[3];
//a[b];

//Fall(-c.vv * e + 3 * 2 + x.cv);

/*
nullary :: () -> void {
	printf("gg\%s", "ssg");

	x : int = 4;
	if (x + 2 * 3 >= 4 * 2) {
		printf("x is %d\n", x);
	}
}
*/

//Vector :: struct(T : Type) {
//	T val;
//}
