/*
vec3 :: struct {
	x: float = 0.0;
	y: float = 0.0;
	z: float = 0.0;
}

ms :: struct {
	x : float;
	y : float^ [1+22*4+1];
	z : int[];
	//w : GG(int, float);
}

ms_ld :: (m: ms^, i: int) -> float {
	return ^((^m).y[i]);
}
*/

fg :: (m: int^) -> int {
	return ^m * 2;
}

gg :: (a: int, b : int) -> int {
	fa: int = fg(a^);
	fb: int = fg(b^);
	return fa * fb;
}

/*
y: float^[1 + 22 * 4 + 1]^ = 4;

ss: bool = true;
st: bool = false;
*/

/*
vec3i :: struct {
x: int = 0;
y: int = 0;
z: int = 0;// 4 - 2 * (3 + -555);
}

vec3 :: struct {
x: float = 0.0;
y: float = 0.0;
z: float = 0.0;
}

dot :: (a: vec3, b: vec3) -> float{
	return a.x*b.x + a.y*b.y + a.z*b.z;
}

make_vec :: (x: float, y: float, z: float) -> vec3 {
	v: vec3;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}
*/

/*
cc: int[];

fg :: () -> int[] {
	return cc;
}

cc2: int[3];

fg2 :: () -> int[3] {
	return cc2;
}

fg3 :: () -> int {
	return cc[1];
}

fg4 :: () -> int {
	return cc2[5];
}

fg5 :: (a: int) -> int {
	return cc2[a * 3 - 1];
}

fArr: float[];

fg6 :: (a: int) -> float {
	return fArr[a];
}

KeyPoint :: struct {
x: float;
y: float;
theta: float;
hashes: int[8];
}

kpt: KeyPoint;

gkpt :: () -> KeyPoint^ {
	return kpt^;
}

do_kpt :: () -> int {
	cd: KeyPoint^ = gkpt();
	return ((^cd).hashes[0]);
}
*/

/**
ci: int = 4;

fg :: () -> int^ {
	return ci^;
}

get_val :: (x: int^) -> int {
	return ^x;
}

do_work :: () -> int {
	return get_val(fg());
}
*/

/*
gg :: () -> int {
	return 1;
}

ff :: () -> int {
	a : int = gg();
	a = gg();
	return gg();
}


dd: int^;

get_dd :: () -> int^ {
	return dd;
}

do_dd :: (a: int^, b : int^) -> int {
	return 2;
}

do_thing :: () -> int {
	do_dd(get_dd(), get_dd());
	return 1;
}

*/

/*
fac :: (n: int) -> int {
	return fac(n - 1);
}

pow :: (b : int, e : int) -> int {
	return -b * e + c;
}

powf :: (a : float, b : float) -> float {
	return a * b;
}

powf_2 :: (x : float) -> float {
	return powf(x, x);
}

pow_2 :: () -> int {
	return pow(c, c) + pow(c, c - 5) * pow(c * 4 + c, 0);
}

ff :: () -> string {
	return "yo";
}
*/
/*
vec3 :: struct {
//x: float = 0.0;
//y: float = 0.0;
//z: float = 0.0*123.4;// 4 - 2 * (3 + -555);
asI: vec3i;
}
*/

/*
vec3 :: struct {
x: float = 0;
y: float = 0;
z: float = 0;
}

makeVec :: (x : float, y: float, z: float) -> vec3 {
	v : vec3;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}


norm2 :: (v : vec3) -> float {
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
*/

/*
pow :: (b : int, e : int) -> int {
	return -b.xc * e;
}
*/

//p(-b.xc * e);
//cc.v + b.a[p(-b.cc^*34 + er.c^*^t.x^ * h * ^(x.cc + 55))];

//x[c] * (^v[h])[a[b*c[4]]];
//mm.cc[3];
//a[b];

//Fall(-c.vv * e + 3 * 2 + x.cv);

/*
nullary :: () -> void {
	printf("gg\%s", "ssg");

	x : int = 4;
	if (x + 2 * 3 >= 4 * 2) {
		printf("x is %d\n", x);
	}
}
*/

//Vector :: struct(T : Type) {
//	T val;
//}
