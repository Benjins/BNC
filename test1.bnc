/*vec3 :: struct {
	x: float = 0;
	y: float = 0;
	z: float = 0;
}

ms :: struct {
	x : float;
	y : float^ [1+22*4+1] ^;
	z : int[..];
	w : GG(int, float);
}*/

/*
y: float^[1 + 22 * 4 + 1]^ = 4;

ss: bool = true;
st: bool = false;
*/



vec3i :: struct {
x: int = 0;
y: int = 0;
z: int = 0;// 4 - 2 * (3 + -555);
}

vec3 :: struct {
x: float = 0.0;
y: float = 0.0;
z: float = 0.0;
}

dot :: (a: vec3, b: vec3) -> float{
	return a.x*b.x + a.y*b.y + a.z*b.z;
}

make_vec :: (x: float, y: float, z: float) -> vec3 {
	v: vec3;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}

/*
gg :: () -> int {
	return 1;
}

ff :: () -> int {
	a : int = gg();
	a = gg();
	return gg();
}


dd: int^;

get_dd :: () -> int^ {
	return dd;
}

do_dd :: (a: int^, b : int^) -> int {
	return 2;
}

do_thing :: () -> int {
	do_dd(get_dd(), get_dd());
	return 1;
}

*/

/*
fac :: (n: int) -> int {
	return fac(n - 1);
}

pow :: (b : int, e : int) -> int {
	return -b * e + c;
}

powf :: (a : float, b : float) -> float {
	return a * b;
}

powf_2 :: (x : float) -> float {
	return powf(x, x);
}

pow_2 :: () -> int {
	return pow(c, c) + pow(c, c - 5) * pow(c * 4 + c, 0);
}

ff :: () -> string {
	return "yo";
}
*/
/*
vec3 :: struct {
//x: float = 0.0;
//y: float = 0.0;
//z: float = 0.0*123.4;// 4 - 2 * (3 + -555);
asI: vec3i;
}
*/

/*
vec3 :: struct {
x: float = 0;
y: float = 0;
z: float = 0;
}

makeVec :: (x : float, y: float, z: float) -> vec3 {
	v : vec3;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}


norm2 :: (v : vec3) -> float {
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
*/

/*
pow :: (b : int, e : int) -> int {
	return -b.xc * e;
}
*/

//p(-b.xc * e);
//cc.v + b.a[p(-b.cc^*34 + er.c^*^t.x^ * h * ^(x.cc + 55))];

//x[c] * (^v[h])[a[b*c[4]]];
//mm.cc[3];
//a[b];

//Fall(-c.vv * e + 3 * 2 + x.cv);

/*
nullary :: () -> void {
	printf("gg\%s", "ssg");

	x : int = 4;
	if (x + 2 * 3 >= 4 * 2) {
		printf("x is %d\n", x);
	}
}
*/

//Vector :: struct(T : Type) {
//	T val;
//}
